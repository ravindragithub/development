public with sharing class Service_HTSRegions {
  //Some of the common elements will migrate into Service_base
  public static serviceResults log {get; private set;}
  public static Integer warningCount {get; private set;}

  public Service_HTSRegions() {
    
  }
  static {
    log = new serviceResults();
    log.success = true;       //optimistic initialization....
    log.message = DateTime.now() + '\t' + 'SERVICE_INITIALIZATION\t' + 'Initializing HTS Regions Service Service';
    warningCount = 0;
  }
  public static serviceResults getLog(){
    return log;
  }
  public static Integer getWarningCount(){
    return warningCount;
  }
  //Main Method 1
  public static serviceResults QoSupdates(list<String> terminals){
    String methodName = 'QoSupdates(list<String> terminals)';
    log.appendLog('METHOD_ENTRY', methodName + '|Begin HTS QOS Update process..');

    preProcessValidation(terminals);
    if(log.success == false){ return returnFatalError(); }
    //Main loop we try really hard to complete!! no Bailouts!
    for(String vtid : terminals){
      //Get subscriber details...
      list<HTSOSS_hts_subscribers> readSubs = new list<HTSOSS_hts_subscribers>();
      readSubs.addAll(readSubsFromOSS(vtid + '-00'));
      readSubs.addAll(readSubsFromOSS(vtid + '-01'));
      readSubs.addAll(readSubsFromOSS(vtid + '-02'));
      //Perform Analysis...
      warningCount = warningCount + subscriberAnalysis(readSubs, vtid);
      //PUT subscribers back to OSS..
      for(HTSOSS_hts_subscribers sub : readSubs){
        warningCount = warningCount + updateShapingPolicy(sub);
      }
    }

    log.appendLog('METHOD_EXIT', methodName + '|HTS QOS Updates finished for: ' + terminals.size() + ' Terminals!');
    if (log.success){
      if(log.srCase != null){
        log.srCase.Description = log.srCase.Description + '\n' + log.message;   //append log.message to stack trace from Exception
        insert log.srCase;
        log.appendLog('CASE_CREATED', 'Record ID: ' + log.srCase.Id);
      }
      if(warningCount > 0){
        Exception ex = new NoDataFoundException();  //Create, but do not throw an exception as an input to the method
        ex.setMessage(warningCount + ' warnings generated by Service_HTSRegions Class!');
        log.createCase(ex);
        log.srCase.Description = log.srCase.Description + '\n' + log.message;   //append log.message to stack trace from Exception
        insert log.srCase;
        log.appendLog('CASE_CREATED', 'Record ID: ' + log.srCase.Id);
      }
      log.appendLog('SERVICE_FINISHED', 'SUCCESS: HTS QOS Updates Service completed successfully!');
    } else {
      return returnFatalError();
    }
    system.debug(CalloutLogs.commitLogs());                     //do this LAST just before returning from method
    return log;
  }
  //Main Method 2
  public static serviceResults updateTerminal(String vtid, String serviceIP, String template, Decimal terminalType){
    String methodName = 'updateTerminal(HTSOSS_hts terminalsToUpdate)';
    log.appendLog('METHOD_ENTRY', methodName + '|Begin Terminal Update Service...');
    //get terminal details from OSS
    HTSOSS_hts_terminals termToReplace = getTerminalDetails(vtid);
    if(log.success == false){ return returnFatalError(); }
    //instanciate an asynch terminal, replacing attributes as required...

    Integer termTypeId = Integer.valueOf(terminalType); //Salesforce Framework issue....
    //not re-casting as an Integer causes FATAL_ERROR Internal Salesforce.com Error

    HTSOSS_hts_terminals_asynch termToReplaceAsync = convertToAsynch(serviceIP, template, termTypeId, termToReplace);
    if(log.success == false){ return returnFatalError(); }
    //invoke the "replace" job
    HTSOSS_hts_terminals_replace replacementJob = enqueueReplaceJob(termToReplaceAsync);
    if(log.success == false){ return returnFatalError(); }
    //Ensure that job ID is returned in service log

    log.appendLog('METHOD_EXIT', methodName + '|Terminal Update Service finished for: ' + vtid);
    if (log.success){
      if(log.srCase != null){
        log.srCase.Description = log.srCase.Description + '\n' + log.message;   //append log.message to stack trace from Exception
        insert log.srCase;
        log.appendLog('CASE_CREATED', 'Record ID: ' + log.srCase.Id);
      }
      log.appendLog('SERVICE_FINISHED', 'SUCCESS: Terminal Update Service completed successfully!');
    } else {
      return returnFatalError();
    }
    system.debug(CalloutLogs.commitLogs());                     //do this LAST just before returning from method
    return log;

  }

  //Private methods
  @testVisible private static serviceResults returnFatalError(){
    if(log.srCase == null){
      Exception ex = new NoDataFoundException();  //Create, but do not throw an exception as an input to the method
      ex.setMessage('Fatal Error in Service_HTSRegions Class');
      log.createCase(ex);
    }
    log.srCase.Description = log.srCase.Description + '\n' + log.message;   //append log.message to stack trace from Exception
    insert log.srCase;
    log.appendLog('CASE_CREATED', 'Record ID: ' + log.srCase.Id);
    log.appendLog('SERVICE_FINISHED', 'ERROR: HTS Regions Service failed to complete successfully. See log for details.');
    system.debug(CalloutLogs.commitLogs());                     //do this LAST just before returning from method
    return log;
  }
  @testVisible private static void preProcessValidation(list<String> terminals){
    String methodName = 'preProcessValidation(list<String> terminals)';
    log.appendLog('METHOD_ENTRY', methodName + '|Validating Terminal IDs submitted');
    if(terminals.size() == 0){
      log.appendLog('METHOD_EXIT', methodName + '|Service requires a list of Terminal IDs');
      log.appendLog('FATAL_ERROR', terminals.size() + ' Terminal IDs submitted');
      log.success = false;
      return;
    }
    Integer goodTids = 0;
    Integer badTids = 0;
    // First, instantiate a new Pattern object "MyPattern"
    // 8 numbers, no leading or training zeros...
    Pattern MyPattern = Pattern.compile('^[1-9]{1}[0-9]{6}[1-9]{1}$');
    for(String vtid : terminals){
      // Then instantiate a new Matcher object "MyMatcher"
      Matcher MyMatcher = MyPattern.matcher(vtid);
      // You can use the system static method assert to verify the match
      if(! MyMatcher.matches()){ // got a bad VTID, log it and carry on
        badTids++;
        log.appendLog('FATAL_ERROR', vtid + ' Is an invalid Virtual Terminal ID!');
        log.success = false;
      }
      goodTids++;
    }
    if(log.success != true){
      log.appendLog('FATAL_ERROR', methodName + '|' + badTids + ' Out of ' + terminals.size() + ' Terminal IDs invalid!');
    }
    log.appendLog('METHOD_EXIT', methodName + '|' + goodTids + ' Valid Terminal IDs submitted');
    return;
  }
  @testVisible private static list<HTSOSS_hts_subscribers> readSubsFromOSS(String oneTrafficId){
    String methodName = 'readSubsFromOSS(list<String> terminals)';
    log.appendLog('METHOD_ENTRY', methodName + '|Reading Subscribers from OSS for Traffic ID: ' + oneTrafficId);
    list<HTSOSS_hts_subscribers> returnList = new list<HTSOSS_hts_subscribers>();
    HTSOSS_hts_subscribers oneSubscriber = new HTSOSS_hts_subscribers();
    HTSOSS_hts_subscribers.subscribers_list_wrapper wrappedSub = oneSubscriber.getSubscribersList(null, oneTrafficId);
    if(wrappedSub.subscribers_list.size() == 0){
      log.appendLog('INFO', methodName + '|No Subscribers in OSS for: ' + oneTrafficId);
    } else if(wrappedSub.subscribers_list.size() > 1){
      warningCount++;
      log.appendLog('WARNING', methodName + '|' + wrappedSub.subscribers_list.size() + ' Duplicate Subscribers in OSS for: ' + oneTrafficId);
      returnList.addAll(wrappedSub.subscribers_list);
    } else {
      log.appendLog('INFO', methodName + '|One Subscriber in OSS for: ' + oneTrafficId);
      returnList.addAll(wrappedSub.subscribers_list);
    }
    log.appendLog('METHOD_EXIT', methodName + '|Returning Subscribers from OSS for Traffic ID: ' + oneTrafficId);
    return returnList;
  }
  @testVisible private static Integer subscriberAnalysis(list<HTSOSS_hts_subscribers> subscribersList, String vtid){
    String methodName = 'subscriberAnalysis(list<HTSOSS_hts_subscribers> subscribersList, String vtid)';
    log.appendLog('METHOD_ENTRY', methodName + '|Begining Subscriber Analysis for: ' + vtid);
    Integer subscriberWarnings = 0;
    Integer subsListSize = subscribersList.size();
    if(subsListSize == 0){
      //Create a Warning Case, there should ALWAYS be at least an Enabled subscriber
      subscriberWarnings++;
      log.appendLog('WARNING', methodName + '|' + vtid + ' has ZERO Subscribers in OSS!');
    } else if (subsListSize == 1 && subscribersList[0].subscriber_id.right(3) != '-00'){
      //Create a Warning Case, the Enabled subscriber should always end with -00
      subscriberWarnings++;
      log.appendLog('WARNING', methodName + '|SINGLE Subscriber in OSS for: ' + subscribersList[0].subscriber_id + ' Does NOT appear to have the Appropriate Traffic Identifier!');
    } else if (subsListSize == 2){
      //Should have a -01 and a -02
      map<String, HTSOSS_hts_subscribers> subsMap = new map<String, HTSOSS_hts_subscribers>();
      for(HTSOSS_hts_subscribers sub : subscribersList){
        subsMap.put(sub.subscriber_id, sub);
      }
      if(subsMap.size() != 2){
        subscriberWarnings++;
        log.appendLog('WARNING', methodName + '|Duplicate Traffic Identifiers detected: ' + subsMap.keySet());
      }
      if(subsMap.get(vtid + '-01') == null || subsMap.get(vtid + '-02') == null){
        subscriberWarnings++;
        log.appendLog('WARNING', methodName + '|Abnormal Traffic Identifiers detected: ' + subsMap.keySet());
      }
    } else if(subsListSize> 2){
      //Too many subscribers!
      subscriberWarnings++;
      log.appendLog('WARNING', methodName + '|Found: ' + subsListSize + ' Subscribers related to: ' + vtid + ' in OSS!');
    }
    log.appendLog('METHOD_EXIT', methodName + '|Completed Subscriber Analysis for: ' + vtid);
    return subscriberWarnings;
  }
  @testVisible private static Integer updateShapingPolicy(HTSOSS_hts_subscribers oneSubscriber){
    String methodName = 'updateShapingPolicy(HTSOSS_hts_subscribers oneSubscriber)';
    log.appendLog('METHOD_ENTRY', methodName + '|Updating via PUT: ' + oneSubscriber.subscriber_id);
    Integer calloutWarnings = 0;
    HTSOSS_hts_subscribers subToPUT = new HTSOSS_hts_subscribers();
    subToPUT.subscriber_plan_id = oneSubscriber.subscriber_plan_id;
    subToPUT.obj_id = oneSubscriber.obj_id;
    subToPUT.subscriber_id = oneSubscriber.subscriber_id;
    subToPUT.message = '';
    try{
      subToPUT = subToPUT.putSubscriber(subToPut);
      if(subToPUT.response_code == 204){          //Success!!
        log.appendLog('METHOD_EXIT', methodName + '|Sucessfully updated via PUT: ' + oneSubscriber.subscriber_id);
      } else if(subToPUT.response_code == 404){   //Not found
        calloutWarnings++;
        log.appendLog('WARNING', methodName + '|404 Subscriber not found in OSS: ' + subToPUT.subscriber_id);
        log.appendLog('WARNING', methodName + '|OSS Returned: ' + subToPUT.message);
      } else if(subToPUT.response_code == 400){   //Subscriber Details Invalid
        calloutWarnings++;
        log.appendLog('WARNING', methodName + '|400 Subscriber details not valid. No Call to OSS was made: ' + subToPUT.subscriber_id + ', ' + subToPUT.obj_id);
      } else if(subToPUT.response_code == 500){   //OSS Error
        calloutWarnings++;
        log.appendLog('WARNING', methodName + '|500 OSS Error: ' + subToPUT.subscriber_id);
        log.appendLog('WARNING', methodName + '|OSS Returned: ' + subToPUT.message);
      } else {                                    //WFT?!? Unknown Error
        calloutWarnings++;
        log.appendLog('WARNING', methodName + '|Unknown Error: ' + subToPUT.subscriber_id);
        log.appendLog('WARNING', methodName + '|OSS Returned: ' + subToPUT.message);
      }
    } catch(exception e){
      calloutWarnings++;
      log.appendLog('WARNING', methodName + '|Exception caught: ' + e.getMessage());
      log.appendLog('WARNING', 'Could not Update Subscriber in OSS: ' + e.getStackTraceString());
    }
    return calloutWarnings;
  }
  //Terminal update exclusive methods
  //This method is used by they hybrid management system to help decide if a configuration template should be updated or not.
  /*@testVisible private*/@AuraEnabled public static HTSOSS_hts_terminals getTerminalDetails(String VTID){
    String methodName = 'getTerminalDetails(String VTID)';
    HTSOSS_hts_terminals returnObj = new HTSOSS_hts_terminals();
    try{
      log.appendLog('METHOD_ENTRY', methodName + '|Getting terminal details from Virtual Terminal Id: ' + VTID);
      HTSOSS_hts_terminals util = new HTSOSS_hts_terminals();
      system.debug('Step 2a. GET Terminals (a list of ONE filtered by NAME)');
      HTSOSS_hts_terminals.terminals_list_wrapper terminalList = new HTSOSS_hts_terminals.terminals_list_wrapper();
      terminalList = util.getTerminals(null, VTID);
      //We might get one, or none... probably shouldn't get two!
      if(terminalList.terminals_list.size() != 1){  //this would be a problem...
        log.appendLog('METHOD_EXIT', methodName + '|Service failed to find one and only one Terminal with identity: ' + VTID);
        log.appendLog('FATAL_ERROR', terminalList.terminals_list.size() + ' Terminals with: ' + VTID + ' returned from OSS!');
        log.success = false;
        return returnObj;
      }
      system.debug('A list of one Terminal: ' + terminalList);
      returnObj = terminalList.terminals_list[0];
      returnObj = util.getTerminal(returnObj);
      if(returnObj.response_code != 200){
        log.appendLog('METHOD_EXIT', methodName + '|Service failed to GET all details for Terminal with identity: ' + VTID);
        log.appendLog('FATAL_ERROR', 'OSS returned: ' + returnObj.response_code + ' with message: ' + returnObj.message);
        log.success = false;
        return returnObj;
      }
      returnObj.message = 'SUCCESS: retrieved results for one Terminal';
    } catch (exception e){
      log.appendLog('METHOD_EXIT', methodName + '|An Exception has been caught.');
      log.appendLog('FATAL_ERROR', 'Could not GET Terminal from OSS. Line number: ' + e.getLineNumber() + ' Message: ' + e.getMessage());
      log.success = false;
      log.createCase(e);  //use the system thrown exception as an input to the method
      return returnObj;
    }
    log.appendLog('METHOD_EXIT', methodName + '|Successfully obtained details for Terminal with identity: ' + returnObj.terminal_id);
    return returnObj;
  }
  @testVisible private static HTSOSS_hts_terminals_asynch convertToAsynch(String serviceIP, String template, Integer terminalType, HTSOSS_hts_terminals termToConvert){
    String methodName = 'convertToAsync(HTSOSS_hts_terminals termToConvert)';
    HTSOSS_hts_terminals_asynch returnObj = new HTSOSS_hts_terminals_asynch();
    log.appendLog('METHOD_ENTRY', methodName + '|Converting Terminal to asynchronous Object');
    //POST requires six attributes
    returnObj.coremodule_id = termToConvert.coremodule_id;
    returnObj.mgmtipaddress = termToConvert.mgmtipaddress;
    if(template != null){
      returnObj.template_id = template;
    } else {
      returnObj.template_id = termToConvert.template_id;
    }
    //terminal_service_ip looks like "10.64.31.1"... but we want "10.64.31.0/24" for POST!
    if(serviceIP != null){
      returnObj.terminal_ip_address = serviceIP.substringBeforeLast('.') + '.0/24';
    } else {
      returnObj.terminal_ip_address = termToConvert.terminal_service_ip.substringBeforeLast('.') + '.0/24';
    }
    returnObj.terminal_id = termToConvert.terminal_id;
    if(terminalType != null){
      returnObj.terminaltype_id = terminalType;
    } else {
      returnObj.terminaltype_id = termToConvert.terminaltype_id;
    }
    
    log.appendLog('METHOD_EXIT', methodName + '|Successfully converted Terminal to asynchronous Object');
    return returnObj;
  }
  @testVisible private static HTSOSS_hts_terminals_replace enqueueReplaceJob(HTSOSS_hts_terminals_asynch termToReplaceAsync){
    String methodName = 'enqueueReplaceJob(HTSOSS_hts_terminals_asynch)';
    log.appendLog('METHOD_ENTRY', methodName + '|Preparing to replace terminal: ' + termToReplaceAsync.terminal_id);
    HTSOSS_hts_terminals_replace util = new HTSOSS_hts_terminals_replace();
    HTSOSS_hts_terminals_replace returnObj = new HTSOSS_hts_terminals_replace();
    list<HTSOSS_hts_terminals_asynch> termsToReplace = new list<HTSOSS_hts_terminals_asynch>();
    try{
      termsToReplace.add(termToReplaceAsync);
      util.terminals = termsToReplace;
      returnObj = util.postTerminalsToReplace(util);
      if(returnObj.response_code != 202){
        log.appendLog('METHOD_EXIT', methodName + '|Service failed to create replace job for: ' + termToReplaceAsync.terminal_id);
        log.appendLog('FATAL_ERROR', 'OSS returned: ' + returnObj.response_code + ' with message: ' + returnObj.message);
        log.success = false;
        return returnObj;
      } else if(returnObj.terminals.size() != 1){ //too many or too few jobs!
        log.appendLog('METHOD_EXIT', methodName + '|Abnormal job creation for: ' + termToReplaceAsync.terminal_id +  ' OSS created: ' + returnObj.terminals.size() + ' jobs');
        log.appendLog('FATAL_ERROR', 'OSS returned: ' + returnObj.terminals.size() + ' Terminals, should have been 1');
        log.success = false;
        return returnObj;
      } else {  //everything is cool!
        log.appendLog('INFO', 'Job ID: ' + returnObj.terminals[0].obj_id); //returned from call, is the Job ID
      }
    } catch(exception e){
      log.appendLog('METHOD_EXIT', methodName + '|An Exception has been caught.');
      log.appendLog('FATAL_ERROR', 'Could not GET Terminal from OSS. Line number: ' + e.getLineNumber() + ' Message: ' + e.getMessage());
      log.success = false;
      log.createCase(e);  //use the system thrown exception as an input to the method
      return returnObj;
    }
    log.appendLog('METHOD_EXIT', methodName + '|');
    return returnObj;
  }
}